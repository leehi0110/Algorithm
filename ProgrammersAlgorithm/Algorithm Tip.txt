유클리드호제법

Greatest Common Divisor ( GCD )
a, b의 최소공배수
r = a%b
b != 0 => a = b => b = r => r = a%b 반복
b == 0 => a가 최대공약수

Least Common multiple ( LCM )
a, b 의 최대공약수
    최대공약수 * 최소공배수 = a * b
=>  최대공약수 = (a * b) / GCD(a,b)

-------------------------------------------

비트 연산자로 홀수 판별

num & 1 ? "Odd" : "Even"
홀 수는 xxx1 & 0001 => 0001 이기 때문에 1
짝 수는 xxx0 & 0001 => 0000 이기 때문에 0

=> 1 & 1 = 1 / 1 & 0 = 0
=> 1 | 0 = 1 / 1 | 1 = 1
=> 1 ^ 1 = 0 / 1 ^ 0 = 1 or 0 ^ 1 = 1
------------------------------------------ 

#include <bitset>

=> string str = bitset<size_t>(val).to_string()
=> str = binary val

--------------------------------------------

#include <algorithm>

=> max_element() & min_element()
=> 값이 아닌 주소를 반환해줌

=> sort (begin,end) => 기본이 오름차순
=> sort (begin,end,compare)
=> sort (begin, end, greater<자료형>()) => 내림차순
=> sort (begin, end, less<자료형>()) => 오름차순

=> iterator iter = find(STL.begin(),STL.end(),Element);
=> int index = find(STL.begin(),STL.end(),Element) - STL.begin()
=> find 함수는 첫번째로 발견되는 반복자를 반환
=> Element가 없을 경우 STL.end()를 반환

=> reverse(vector.begin(),vector.end());

=> replace(STL.begin(),STL.end(),from,to);
=> ex)   str = "12341234"
=>       replace(str.begin(),str.end(),"1","2");
=>       str = "22342234"


---------------------------------------------

#include <cctype>

=> tolower & toupper 사용가능

=> isdigit('<char>문자') => return 0
=> isdigit('<char>숫자') => return !0

----------------------------------------------

#include <sstream>

=> istringStream alias(string); <= 선언
=> string bufferString; <= 선언


=> while(getline(string, bufferString, delim))
=> {
=>   delim 을 기준으로 끊어서 버퍼 저장
=> }

=> ex1) str = "abcabc"
=>      string = stringbuffer;
=>      stringstream ss(str);
=>      ss.get() // ss에서 가져올 차례의 요소를 가져옴
=>      ss.unget() // 마지막에 가져온 것을 다시 ss에 넣음


----------------------------------------------

#include <numeric>

result = accumulate(STL.begin(),STL.end(),init val);
=> long long result일 경우 init val에 0LL으로 해줘야 오류 x

------------------------------------------------

#include <string>

=> string num = "1234"
=> int number = stoi(num);
=> cout << number << endl;
=> 결과는 int 1234

=> string s = "123123";
=> cout << s.find("123") << endl;
=> 결과는 123이 처음으로 매칭되는 index 반환
=> 매칭되지 않을 경우 -1 반환

=> string.substr(index,len) index ~ index+len
=> string s = abcdefgh;
=> s.substr(5) = fgh
=> s.substr(0,5) = abcde

-----------------------------------------------
